1. At line 12, the code will output the value of 3. Since `i` was declared using the `var` inside the function, it has function scope, meaning it is accessible throughout the entire function. In this case, i will have the value 3 because the loop condition `i < prices.length` will become false when `i` is incremented to 3 and terminates at `i = 3`. Therefore, the loop will execute three times and `i` will be equal to 3.

2. At line 13, it will output the value of 150. This is because the output of the discountedPrices will be the last value of discountedPrices calculated in the for loop, which is the discounted price of the last item in the `prices` array, which is 300. Based on the formula, the discountedPrices for "300" would be "300 * (1-0.5) = 150". So the output value should be 150. And it is declared as `var`, so it is accessible throughout entire function or all blocks.

3. At line 14, it will output the value of 150. `finalPrice` is declared as This is because Math.round would round a number to the nearest integer by rounding the discounted price to two decimal places before pushing it into the `discounted` array. For the final `discountedPrices` of the last item in the `prices` array, it is 150, and then Math.round(150*100) / 100 would still be `150` for finalPrice variable. And it is declared as `var`, so it is accessible throughout entire function or all blocks.

4. The function would return the value of [50, 100, 150]. For each iteration of the for loop on the 3 elements in the `prices` array, it would first access 100, get discounted price with 50, and then final price is the nearst integer that would be rounded to 50, then this final price of 50 would be pushed into the `discounted` array as first element. Process the same step for the second element 200 and the third element 300 to get 100, and 150 correspondingly for the second and third elememt in `discounted` array. Ultimatly, we could get our `discounted` array with [50, 100, 150].

5. At line 12, it will output the error message "ReferenceError: i is not defined" for the line "console.log(i);". This is because `i` is declared with `let` inside the for loop block, meaning that it has block scope and is only accessible within the for loop block. Therefore, when the console.log(i) statement is executed outside the loop block, `i` is not defined in that scope, leading to a ReferenceError.

6. At line 13, it will output the error message "ReferenceError: discountedPrices is not defined" for the line "console.log(discountedPrices);". This is because `discountedPrices` is declared using the `let` inside the for loop and it only exists within the block scope of the loop. Therefore, it is not accessible outside the for loop, which explains why the console.log(discountedPrices) statement will throw an error.

7. At line 14, it will output the value of 150, which is the final discounted price of the last item in the `prices` array with 300. The code will not cause an error since `let` for the `finalPrice` is declared outside the for loop block, so it would still be able to print out the `finalPrice` due to the accessibility outside the for loop block. So it will return the value of 150, calculated by multiplying the price by 0.5 and rounding the result.

8. The function will return the value of [50, 100, 150], which is three `discounted` values getting from three inputed elements of the `prices` array. The code will not cause an error since `let` for the discounted arrays is declared outside the for loop block, so it would be able to print out the `discounted` arrays due to the accessibility outside the for loop block. So it will return all three final price that have been pushed into the `discounted` array.

9. At line 11, it will output the error message with "ReferenceError: i is not defined" for the line "console.log(i);". This is because the `i` is defined with `let` inside the for loop block, so it has block scope and is only accessible within the for loop. Since console.log(i) is outside of the for loop block (cannot be acessed), `i` is not defined in that context and so will get a ReferenceError when trying to access it.

10. At line 12, it will output the value of 3, which is the length of the `prices` array. This is because length was assigned the value of prices's length on line 4, and since it was declared with `const`, its value cannot be changed or reassigned within the function. Thus, the value of length will keep with 3. And since the `length` variable is declared outside the for block with function scope, so it could still be accessed outside the for block. 

11. The function will return [50, 100, 150], multiplying with 0.5 to each corresponding element of `prices` array [100, 200, 300] and applying with 50% discount. After each discounted price is calculated, it is pushed into the `discounted` array, and so the function logs the `discounted` array and return it. It will not lead any error because the `discounted` array is declared outside the for loop block, so it could be accessible from outside of the for loop. And a constant array variable means that the variable itself cannot be replaced with a new array, but the values within the array can be manipulated or modified, such as adding/removing new elements. So it will not throw an error when we declare `discounted` array with `const `.

12. 
A. `student.name`
B. `student['Grad Year']`
C. `student.greeting()`
D. `student['Favorite Teacher'].name`
E. `student.courseLoad[0]`

13. 
A. ‘3’ + 2 = ‘32’ since integers map to their exact string representation.
B. ‘3’ - 2 = 1 since '-' operator is used for subtraction between numeric values. When one or both of the operands is not already a number, JavaScript tries to convert them into numbers. In this case, the first operand the string '3' is converted into the number 3 since it only contains digits, and the subtraction operation yields the final numeric result 1.
C. 3 + null = 3 since '+' operator is used for addition between numeric values. In this case, the second operand null is used with a mathematical operator, it is treated as the number 0. Thus, JavaScript will add 3 and 0 together, resulting in the final result of number 3.
D. ‘3’ + null = '3null' since '+' operator is also used for string concatenation between strings. When one or both of the operands is a string, the '+' operator performs string concatenation, meaning to join the two operands together as strings. In this case, null is converted to the string 'null'. Thus, JavaScript will concatenate '3' and 'null' together, resulting in the final result of string '3null'.
E. true + 3 = 4 since as one or both of the operands is not already a number, JavaScript tries to convert them into numbers. In this case, a boolean value true is converted to a number 1. Thus, add 1 to the number 3, resulting in the final result of number 4.
F. false + null since as one or both of the operands is not already a number, JavaScript tries to convert them into numbers. In this case, a boolean value false is converted to a number 0. And the second operand null is also treated as 0. Thus, 0 added with 0, resulting in the final result of 0.
G. '3' + undefined = '3undefined' since when one or both of the operands is a string, the '+' operator performs string concatenation. In this case, the first operand '3' is a string, and the second operand undefined is converted to the string 'undefined'. Thus, JavaScript will concatenate '3' and 'undefined' together, resulting in the final result of string '3undefined'.
H. '3' - undefined = NaN, standing for "Not a Number". The '-' operator is used for subtraction. When one or both of the operands is not already a number, JavaScript tries to convert them into numbers. In this case, the first operand '3' is converted to a number, 3 since it only contains digits. However, the second operand undefined is treated as NaN. Thus, JavaScript will subtract NaN from the number 3, resulting in final result of NaN.

14. 
A. ‘2’ > 1 would output the boolean value true. The `>` operator is used for greater than comparison between numeric values. When one or both of the operands is a string, JavaScript tries to convert it to a number. In this case, the string '2' can be converted to the number 2, which is greater than the number 1.
B. ‘2’ < ‘12’ would output the boolean value false. Since '2' and '12' are both strings, Javascript compares them character by character. The kth letter of the first string is compared with the kth letter of the second string. In this case, first '2' (in '2') and '1' (in '12') will be compared. As the ASCII value of '2' (in '2') is greater than ASCII value of '1' (in '12'), so false is returned.
C. 2 == ‘2’ would output the boolean value true. The `==` operator performs type coercion if necessary to compare values. JavaScript will try to convert the operands to the same type if they are different. In this case, the integer 2 will be coerced to a string, so the comparison becomes '2' == '2', which is true.
D. 2 === ‘2’ would output the boolean value false. Since the `===` operator checks for strict equality, meaning that the operands must be of the same type and have the same value. In this case, 2 is a number and '2' is a string, so they are not the same type. Thus, the expression returns false.
E. true == 2 would output the boolean value false. This is because when using the `==` operator, JavaScript performs type coercion to convert the operands to a common type. In this case, the boolean value true is coerced to the number 1, so the expression becomes 1 == 2. Since 1 and 2 are not equal, the expression returns false.
F. true === Boolean(2) would output the boolean value true. Since the `Boolean()` function would convert its argument to a boolean value, for any non-zero numeric value argument, the function returns true. In this case, Boolean(2) return the boolean value true. The `===` operator then checks for strict equality, and since they are of the same type and have the same value, the expression thus returns true.

15. In JavaScript, both the `==` and `===` operators are used for comparison between two values for equality. The difference between the `==` and `===` operators are: The `==` operator is known as the equality operator, allowing for type coercion. This means that JavaScript will try to convert the values to a common type before making the comparison. For example, if one value is a string and the other is a number, JavaScript will convert the string to a number before making the comparison. For example, '2' == 2 would return true. However, the `===` operator is known as the strict equality operator, not allowing for type coercion. This means that if the types of the two values being compared are different, the '===' operator will always return false, even if the values themselves are similar. For example, '2' === 2 would return false.

16. Code available in another file part2-question16.js

17. The result would be an array containing the values [2, 4, 6]. The for loop iterates over each element in the inputted array argument. For each element `array[i]`, the callback function, `doSomething` is simply called with the element as its argument, and returns that number multiplied by 2. So when `modifyArray` is called with the `array` [1, 2, 3], it will iterate over each element of the array, and double the value of each element using the `doSomething` function, and push the doubled value to the `newArr` array. So the resulting `newArr` array will be [2, 4, 6], which is the final result returned by the `modifyArray` function.

18. Code available in another file part2-question18.js

19. The output would be `1`, `4`, `3`, `2` (1 4 3 2).